Las pruebas de conocimiento cero, o en inglés \zeroknowledge (\zk) Proofs~\cite{goldwasser1985knowledge}, son protocolos criptográficos interactivos entre 2 actores. Permiten a una de las partes (el \textit{prover}) demostrar a otra parte (el \textit{verifier}) que una afirmación matemática es verdadera sin revelar nada más que la veracidad de la misma. En el uso cotidiano tanto el prover como el verifier son programas informáticos y por ende todas las partes del protocolo están automatizadas.

Por otro lado, otra familia de protocolos llamados \textbf{SNARKS} (Succint Non-Interactive ARgument of Knowledge) permiten demostrar la ejecución de un programa conocido por ambas partes. Esto se consigue modelándolo como un sistema de ecuaciones que representa todos los estados intermedios del cómputo y demostrando que se conoce una solución para ese sistema de ecuaciones. Estas familias de protocolos no son disjuntas, ya que combinando las ideas de ambas se obtienen protocolos que denominamos \textbf{ZK-SNARK}.

En los últimos años, la investigación sobre estos protocolos tuvo un crecimiento exponencial, y esto se debe principalmente 2 factores: (1) las computadoras alcanzaron un poder de cómputo que transformó estas familias de tecnologías de prohibitivo a tratable; (2) el hecho de que los SNARKs proveen un método para escalar eficientemente las tecnologías Blockchain~\cite{huang2024data}. Si bien estas son áreas que tuvieron muchos avances últimamente, todavía presentan desafíos y están en constante movimiento.

Hoy en día existen diversos protocolos e implementaciones que proveen distintas propiedades, como pueden ser mayor velocidad de ejecución, menor tamaño de las pruebas generadas, necesidad de Trusted Setup~\cite{benarroch2019diving}, etc. A su vez cada sistema tiene su propia estrategia para darle forma a las afirmaciones que se desean probar. Un protocolo muy influyente fue PLONK~\cite{PLONK}, que aportó entre otras cosas una forma genérica para expresar programas como restricciones aritméticas. 

En este contexto surgen los Domain Specific Languages (\textbf{DSL}): lenguajes de programación de alto nivel que pueden ser interpretados por distintos sistemas de pruebas. En particular, Noir~\cite{noirIntroduction} es un DSL cuya sintaxis es similar a la de Rust. Noir pretende ser el lenguaje universal de \zk y su estrategia para lograrlo es compilar a una representación intermedia llamada \emph{Abstract Circuit Intermediate Representation} (\textbf{ACIR})~\cite{ACIR}. A partir de esta representación intermedia, cualquier sistema de pruebas (llamados comúnmente \textit{proving systems}) debería tener una representación del programa completo que le permita construir una prueba de su ejecución. Sin embargo, de momento sólo existe un sistema de pruebas capaz de interactuar con código ACIR, llamado Barretenberg~\cite{gabizon2020proposal}. Este sistema de pruebas requiere de un \emph{Common Reference String} (CRS) para funcionar, lo cual es limitante en algunos dispositivos ya que puede requerir mucho espacio de almacenamiento para generar pruebas dependiendo de los parámetros del protocolo.

Plonky2~\cite{PLONKY2} es un sistema de pruebas basado en PLONK (\emph{Plonkish Arithmetization}) pero que a diferencia de Barretenberg, no requiere de un Trusted Setup (y por ende de un CRS) para funcionar. Sin embargo, Plonky2 en este momento no posee la capacidad de interpretar código ACIR, pero cuenta con una API para generar manualmente programas arbitrarios demostrables. 

A partir del limitante de almacenamiento de Barretenberg y la posibilidad de usar la API de Plonky2, se pretende construir una herramienta que permita demostrar la ejecución de programas de alto nivel en dispositivos con almacenamiento limitado. Más específicamente se propone extender Plonky2 con la posibilidad de interpretar código ACIR. 

El trabajo estará estructurado de forma tal que el conocimiento previo necesario para entenderlo sea mínimo, es decir, que alcance con ser graduado de CS de la computación. Primero se brindará background suficiente para tener un entendimiento completo del problema a solucionar y luego se dará lugar al desarrollo. 