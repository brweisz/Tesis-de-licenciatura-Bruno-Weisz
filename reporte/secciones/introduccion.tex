Las pruebas de conocimiento cero, o en inglés \zeroknowledge (\zk) Proofs~\cite{goldwasser1985knowledge}, son protocolos criptográficos interactivos entre 2 actores. Permiten a una de las partes (el probador) demostrar a otra parte (el verificador) que una afirmación matemática es verdadera sin revelar nada más que la veracidad de la misma. En el uso cotidiano tanto el probador como el verificador son programas informáticos y por ende todas las partes del protocolo están automatizadas. Una de las capacidades de esta técnica es la de demostrar la ejecución de un programa conocido por ambas partes. Esto se consigue modelándolo como un sistema de ecuaciones que representa todos los estados intermedios del cómputo y demostrando que se conoce una solución para ese sistema de ecuaciones. 

En los últimos años, la investigación sobre estos protocolos tuvo un crecimiento exponencial y esto se debe principalmente a dos factores: (1) las computadoras alcanzaron un poder de cómputo que transformó esta familia de tecnologías de prohibitivo a tratable; (2) el hecho de que proveen un método para escalar eficientemente las tecnologías Blockchain~\cite{huang2024data}. Si bien esta es un área que tuvo muchos avances últimamente, todavía presenta desafíos y está en constante movimiento.

Hoy en día existen diversos protocolos e implementaciones de pruebas ZK que proveen distintas propiedades, como pueden ser mayor velocidad de ejecución, menor tamaño de las pruebas generadas, necesidad de Trusted Setup~\cite{benarroch2019diving}, etc. A su vez cada sistema tiene su propia estrategia para darle forma a las afirmaciones que se desean probar. Un protocolo muy influyente fue PLONK~\cite{PLONK}, que aportó entre otras cosas una forma genérica para expresar programas como restricciones aritméticas. 

En este contexto surgen los Domain Specific Languages (\textbf{DSL}): lenguajes de programación de alto nivel que pueden ser interpretados por distintos sistemas de pruebas. En particular, Noir~\cite{noirIntroduction} es un DSL cuya sintaxis es similar a la de Rust. Noir pretende ser el lenguaje universal de \zk y su estrategia para lograrlo es compilar a una representación intermedia llamada \emph{Abstract Circuit Intermediate Representation} (\textbf{ACIR})~\cite{ACIR}. A partir de esta representación intermedia, cualquier sistema de pruebas debería tener una representación del programa completo que le permita construir una prueba de su ejecución. Sin embargo, en la actualidad sólo existe un sistema de pruebas capaz de interactuar con código ACIR, llamado Barretenberg~\cite{gabizon2020proposal}. Este sistema de pruebas requiere de un \emph{Structured Reference String} (SRS) para funcionar, lo cual es limitante en algunos dispositivos ya que puede requerir mucho espacio de almacenamiento para generar pruebas dependiendo de los parámetros del protocolo.

Plonky2~\cite{PLONKY2} es un sistema de pruebas basado en PLONK (\emph{Plonkish Arithmetization}) pero que a diferencia de Barretenberg, no requiere de un Trusted Setup (y por ende de un SRS) para funcionar. Sin embargo, Plonky2 en este momento no posee la capacidad de interpretar código ACIR, pero cuenta con una API para generar manualmente programas arbitrarios demostrables. 

A partir del limitante de almacenamiento de Barretenberg y la posibilidad de usar la API de Plonky2, se pretende construir una herramienta que permita demostrar la ejecución de programas de alto nivel en dispositivos con almacenamiento limitado. Más específicamente se propone extender Plonky2 con la posibilidad de interpretar código ACIR. 

El trabajo estará estructurado de forma tal que el conocimiento previo necesario para entenderlo sea mínimo, es decir, que alcance con ser graduado de CS de la computación. Primero se brindará background suficiente para tener un entendimiento completo del problema a solucionar, dando lugar al desarrollo posterior. 