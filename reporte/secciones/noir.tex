\chapter{Noir}\label{sec:noir}
Noir es un lenguaje de programación que permite generar pruebas de ejecución usando un protocolo ZK-SNARK. Podemos escribir programas tradicionales, librerías y Smart Contracts, aunque vamos a enfocarnos en los programas tradicionales. El prover que usa para esto se llama \textbf{Barretenberg} y está escrito en C++. La versión de Noir usada en este trabajo es la 0.47.0 por motivos que veremos más adelante. A su vez, la versión de Barretenberg usada es la 0.61.0. En el apéndice \ref{sec:apendice_noir} vamos a realizar un análisis en profundidad del flujo que realiza Noir para pasar de un código de alto nivel a una prueba de ejecución a través de su compilador: \textbf{Nargo}. A continuación vamos a extraer los aspectos más relevantes de este flujo.

Una vez que instalamos Nargo y creamos un proyecto, hay que escribir un programa de Noir. Noir tiene una particularidad frente a otros lenguajes: permite distinguir entre inputs públicos y privados. Los inputs privados serán conocidos únicamente por el prover mientras que los públicos serán conocidos también por el verifier. A continuación se ve un ejemplo:

\begin{verbatim}
fn main(x: pub Field, y: Field) {
    assert(x == y*y);
}
\end{verbatim}


¿Qué es lo que hace este programa? \texttt{main} es el punto de entrada, recibe un parámetro público y uno privado y no tiene un valor de retorno. Su propósito en lenguaje coloquial es generar una prueba de ejecución de que el prover conoce el valor de $\sqrt{x}$ en $\Fp$, pero sin revelar su valor. 

A continuación, el prover deberá brindar una asignación de valores concretos para las variables de input, en este caso $x$ e $y$. Esto es necesario para obtener la traza de una ejecución concreta del programa. Se puede tomar por ejemplo \texttt{x = 4, y = 2}. Una vez provistos estos valores, el programa se puede ejecutar para obtener 2 artefactos:

\begin{itemize}
	\item un sistema de restricciones en formato \textbf{ACIR} (\textit{Abstract Circuit Intermediate Representation}). Este está compuesto por un conjunto de \textbf{witnesses}, que son las variables inmutables del programa, y un sistema de ecuaciones que establece restricciones sobre ellas. En términos de PLONK, son las matrices $Q$ y $V$. Veremos más en detalle el código ACIR en la sección \ref{sec:acir}.
	\item un diccionario que asigna valores concretos a todos los witnesses, que tienen que ver con la ejecución concreta del programa dados los inputs suministrados por el prover. En términos de PLONK, son las matrices $T$ y $PI$.
\end{itemize}. 

Para este programa concreto, los witnesses son:
\begin{itemize}
	\item $w_0$ representando a la variable $x$ (pública)
	\item $w_1$ representando a la variable $y$ (privada)
\end{itemize}
y el sistema de restricciones está dado por una única ecuación:
\begin{center}
	$-1 \cdot w_1 \cdot w_1 + 1 \cdot w_0 = 0$, 
\end{center}
que es equivalente a 
\begin{center}
	$w_0 = w_1^2$,
\end{center}

Conceptualmente podemos pensarlo en términos de PLONK como que ya tenemos las matrices $T$ (traza), $Q$ y $V$ (programa) y $PI$ (public inputs). El siguiente paso es generar la prueba de ejecución con un \textbf{prover} específico, en este caso Barretenberg. Alcanza con suministrar a Barretenberg los artefactos que generamos para que este genere la prueba deseada.

Ahora bien, el verifier quiere verificar esta prueba. Va a tener acceso al programa y a los inputs públicos, pero no a los inputs privados. Una prueba no puede ser verificada en el vacío, sino que tiene que ser contextualizada para que tenga significado o semántica. Concretamente, el verifier adempás de la prueba necesita una \textbf{Verifying Key}: un artefacto que contiene la información sobre el programa y los inputs públicos. La VK puede ser armada por el prover y pasada al verifier, o puede ser armada directamente por el verifier. Barretenberg tiene herramientas para crear la VK sin necesidad de generar una prueba. Esto se puede ver en más detalle en el apéndice \ref{sec:apendice_noir}. 

Los comandos usados en cada paso son:
\begin{itemize}
	\item \textbf{prove}: para generar la prueba
	\item \textbf{write\_vk}: para generar la Verification Key
	\item \textbf{verify}: para verificar la prueba (requiere haber generado la VK)
\end{itemize}

\section{ACIR}\label{sec:acir}
El \textit{Abstract Circuit Intermediate Representation} (ACIR) es el bytecode de alto nivel en el cual deriva todo programa escrito en Noir. Esencialmente, un código ACIR determina un sistema de ecuaciones \textbf{en abstracto}. Esto quiere decir que no siempre va a proveer explícitamente todas las ecuaciones polinomiales, sino que muchas veces simplemente va a decir qué características deben cumplir estas ecuaciones, delegando en el proving system la implementación concreta. 

Las variables de este sistema de ecuaciones son los \textbf{witnesses}. Un código ACIR describe qué variables van a ser \textbf{inputs públicos}, \textbf{inputs privados} y \textbf{valores de retorno}. Esto no significa nada para el sistema de ecuaciones en sí, pero provee información para que el proving system pueda replicar el programa escrito en Noir con su propio modelo. Los witnesses están numerados del $0$ en adelante, y los notamos $w_i$ o simplemente $\_i$. Podemos pensar a los witnesses como variables \textbf{inmutables} del programa, aunque en realidad sabemos que su inmutabilidad se debe a que estamos parados en otro modelo: en el de los sistemas de ecuaciones. 

Las instrucciones que describen este sistema de ecuaciones se denominan \textbf{opcodes} y los hay de varios tipos. Ya nos topamos con uno antes cuando estábamos viendo el flujo de un programa de Noir en la figura \ref{fig:ACIR_ejemplo_1}. Todos los opcodes predican sobre witnesses, estableciendo restricciones sobre ellos. Veamos a los opcodes uno por uno:

\subsection{AssertZero}

Un opcode AssertZero determina de forma explícita una restricción polinomial sobre los witnesses. Estas tienen 3 campos posibles:
\begin{itemize}
    \item \textbf{Términos cuadráticos}: una lista $M$ de $|M|$ triplas de la forma $({k_M}_i,w_{M_{i,l}}, w_{M_{i,r}})$ con ${k_M}_i\in \Fp$. Esta lista describe una combinación lineal de productos cuadráticos entre witnesses: 
    $$\sum_{i=0}^{|M|}({k_M}_i\cdot w_{M_{i,l}} \cdot w_{M_{i,r}})$$
    
    \item \textbf{Términos lineales}: una lista $L$ de $|L|$ tuplas de la forma $({k_L}_i,w_{L_i})$ con ${k_L}_i\in \Fp$. Esta lista describe una combinación lineal de witnesses:
    $$\sum_{i=0}^{|L|}({k_L}_i\cdot w_{L_i} )$$
    
    \item \textbf{Constante}: un valor constante $C \in \Fp$.
\end{itemize}
Finalmente, un opcode AssertZero establece la siguiente restricción sobre los witnesses:
$$\sum_{i=0}^{|M|}({k_M}_i\cdot w_{M_{i,l}} \cdot w_{M_{i,r}}) + \sum_{i=0}^{|L|}({k_L}_i\cdot w_{L_i} ) + C = 0$$

Un ejemplo concreto sería
$$\textcolor{red}{3\cdot w_3\cdot w_2 + 5 \cdot w_1 \cdot w_2} \textcolor{blue}{~+~ 4\cdot w_1 + 1 \cdot w_0} \textcolor{orange}{ ~+~ 22} = 0$$

\subsection{Operaciones de memoria}\label{sec:acir_memoria}
En un programa tradicional usamos arreglos para almacenar datos. Noir también provee esa posibilidad, pero ¿cómo esto se traduce a código ACIR? El caso donde queremos leer y escribir posiciones con un indice constante es sencillo: el código ACIR simplemente modela estos casos con AssertZero. El caso intrincado es cuando las posiciones que leemos y escribimos son dinámicas, es decir, cuando no dependen del circuito estático sino de la ejecución concreta del mismo. Para esto, hay operaciones de memoria \textbf{abstractas} para crear un bloque de memoria, escribir en una posición y leer de esa posición. 

Es importante aclarar que las listas en Noir son de tamaño estático: no se pueden agregar ni quitar elementos. También son creadas con valores iniciales para todas sus posiciones. Una intuición de por qué existe esta limitación se verá más adelante en la sección \ref{sec:noir_loops}

\subsubsection{\textbf{MemoryInit}}
Este opcode dicta la creación de un bloque de memoria. El opcode tiene 3 campos:
\begin{itemize}
    \item \textbf{blockId}: es un $n \in \mathbb{N}$ que toma valores del $0$ en adelante para distintos bloques de memoria. Permite identificar y referenciar al bloque más adelante. 
    \item \textbf{init}: una lista $L$ con $n$ witnesses que contienen los valores iniciales de todas las posiciones del arreglo. Dado que $L = [{w_l}_0, {w_l}_1, \cdots, {w_l}_{n-1}]$, los valores del arreglo $A$ estarán restringidos por el proving system a tomar los valores $A[0] = {w_l}_0, ~ A[1]={w_l}_1, \cdots, A[n-1] = {w_l}_{n-1}$ inicialmente. 
\end{itemize}

\subsubsection{\textbf{MemoryRead}}
Este opcode permite “leer'' una posición de memoria. Tiene los siguientes campos:
\begin{itemize}
    \item \textbf{blockId}: una constante para identificar el índice del bloque previamente creado.
    \item \textbf{index}: un witness que representa el índice que se quiere leer del arreglo. Es importante notar que este es un witness y no una constante, y que por ende no es conocida en tiempo de compilación.
    \item \textbf{value}: un witness que está restringido a tomar el valor de la posición de memoria indicada. 
\end{itemize}
Podemos pensar una operación de lectura como una restricción de la forma
$$w_{value} := B_{blockId}[w_{index}]$$ 
Veamos un ejemplo minimal con un programa de Noir como el de la figura \ref{fig:noir_ejemplo_mem_read}. Este programa recibe un arreglo de tamaño 4 y un índice público, y retorna el valor del arreglo en ese índice. Semánticamente, como el arreglo es privado y tanto el índice como el valor de retorno son públicos, este programa está demostrando la afirmación “poseo un arreglo de 4 elementos de $\Fp$ que tiene un valor $x$ en la posición $idx$'' donde tanto $x$ como $idx$ son conocidos por el verifier. 

\begin{figure} 
\centering
\begin{minipage}{\textwidth}
\begin{verbatim}
    fn main(arr: [Field; 4], idx: pub Field) -> pub Field {
        arr[idx]
    }
\end{verbatim}
\end{minipage}
\caption{Programa de Noir minimal con lectura de memoria}
\label{fig:noir_ejemplo_mem_read}
\end{figure}

Podemos ver el ACIR generado para este programa en la figura \ref{fig:ACIR_ejemplo_mem_read}. Vemos que el arreglo es representado inicialmente como 4 witnesses privados independientes, pero luego hay una operación de \texttt{INIT} que usa a esos 4 witnesses para inicializar un bloque de memoria con $id=0$. Luego, hay una operación de lectura que dice que se va a leer el bloque de memoria con $id=0$ en la posición denotada por el witness $w_4$ (que en nuestro caso, es la variable \texttt{idx}), y el valor leido será el mismo que el de $w_6$. Por último, el programa usa un AssertZero para restringir $w_5 = w_6$, ya que $w_5$ es el witness que representará el valor de retorno. 

\begin{figure} 
\centering
\begin{minipage}{\textwidth}
\begin{verbatim}
    private parameters indices : [0, 1, 2, 3]
    public parameters indices : [4]
    return value indices : [5]
    INIT (id: 0, len: 4, witnesses: [_0, _1, _2, _3]) 
    MEM (id: 0, read at: _4, value: _6) 
    EXPR [ (1, _5) (-1, _6) 0 ]
\end{verbatim}
\end{minipage}

\caption{ACIR para el programa de con lectura de memoria}
\label{fig:ACIR_ejemplo_mem_read}
\end{figure}

\subsubsection{\textbf{MemoryWrite}}
Este opcode permite “escribir'' una posición de memoria. Tiene campos similares a los del MemoryRead, pero con distínta semántica:
\begin{itemize}
    \item \textbf{blockId}: una constante para identificar el índice del bloque previamente creado.
    \item \textbf{index}: un witness que representa el índice que se quiere leer del arreglo.
    \item \textbf{value}: un witness que está restringido al valor que se quiere escribir en el arreglo. 
\end{itemize}
Podemos pensar una operación de lectura como una restricción de la forma
$$B_{blockId}[w_{index}] := w_{value}$$ 
Veamos nuevamente un ejemplo minimal con un programa de Noir, como el de la figura \ref{fig:noir_ejemplo_mem_write}. Este programa recibe nuevamente un arreglo de tamaño 4 y un índice público, pero también un valor público que es el que será escrito en el arreglo. Este programa escribe el valor $val$ en la posición $idx$ y finalmente retorna el valor escrito. 



\begin{figure} 
\centering
\begin{verbatim}
fn main(mut arr: [Field; 4], idx: pub Field, val: pub Field) -> pub Field{
    arr[idx] = val;
    arr[idx]
}
\end{verbatim}
\caption{Programa de Noir minimal con escritura de memoria}
\label{fig:noir_ejemplo_mem_write}
\end{figure}

Podemos ver el ACIR generado para este programa en la figura \ref{fig:ACIR_ejemplo_mem_write}. Notamos que en este caso tenemos nuevamente 4 witnesses privados pero 2 públicos (uno para el índice y otro para el valor), y el witness $w_6$ reservado para el valor de retorno. Comenzamos al igual que en el ejemplo anterior con la inicialización del bloque de memoria. El siguiente opcode en este caso es un MemWrite que escribe en el bloque de memoria inicializado en el índice notado por el witness $w_4$ ($idx$) el valor del witness $w_5$ ($val$). Lo siguiente es una operación de lectura, que “guarda'' el valor de ese índice en el witness $w_7$ y por último un AssertZero para igualarlo al witness de retorno con $w_6 = w_7$.

\begin{figure} 
\centering
\begin{minipage}{\textwidth}
\begin{verbatim}
private parameters indices : [0, 1, 2, 3]
public parameters indices : [4, 5]
return value indices : [6]
INIT (id: 0, len: 4, witnesses: [_0, _1, _2, _3]) 
MEM (id: 0, write x5 at: x4) 
MEM (id: 0, read at: x4, value: x7) 
EXPR [ (1, _6) (-1, _7) 0 ]
\end{verbatim}
\end{minipage}

\caption{ACIR para el programa de ejemplo con escritura de memoria}
\label{fig:ACIR_ejemplo_mem_write}
\end{figure}

\subsection{BlackBoxFunctions}
Las funciones de caja negra son una herramienta muy abstracta que tiene el código ACIR para delegar la implementación de una función concreta al proving system. La filosofía detrás de este opcode es la misma que las operaciones de memoria: un código ACIR podría modelar cualquier programa de Noir con una cantidad suficientemente grande de AssertZeros, sin embargo esto es potencialmente muy costoso y puede desaprovechar características propias del proving system que utilicen, como pueden ser las lookup tables mencionadas en la sección \ref{sec:plonk_lookup_tables}. 

Cuando hablamos de “delegar la implementación de una función concreta al proving system'', estamos diciendo que le decimos al proving system “quiero restricciones en tu modelo para esta función especifica, donde los inputs  van a ser estos witnesses y los outputs estos otros witnesses''. Podemos pensarlas como restricciones extremadamente complejas de un sistema de ecuaciones cuya implementación es responsabilidad del prover que interprete el código ACIR.

Algunos ejemplos de estas funciones son:
\begin{itemize}
    \item \texttt{RangeCheck(w, num\_bits)}: opcode que aparece cuando queremos restringir un witness a determinado rango de valores $[0,2^{num\_bits})$. Es útil por ejemplo cuando queremos trabajar con \texttt{u8, u16, u32}. Un ejemplo minimal de programa de Noir que dispararía el uso de un opcode \texttt{BlackBoxFunction::RangeCheck} sería el que se puede ver en la figura \ref{fig:noir_ejemplo_range}. Su ACIR generado se puede ver en \ref{fig:ACIR_ejemplo_range}.
    \begin{figure}[h!]
        \centering
        \begin{verbatim}
        fn main(a: u32) -> pub u32 {
            a
        }
        \end{verbatim}
        \caption{Programa de Noir minimal con RangeCheck}
        \label{fig:noir_ejemplo_range}
    \end{figure}
    \begin{figure}[h!]
        \centering
        \begin{verbatim}
        private parameters indices : [0]
        public parameters indices : []
        return value indices : [1]
        BLACKBOX::RANGE [(_0, num_bits: 32)] [ ]
        EXPR [ (-1, _0) (1, _1) 0 ]
        \end{verbatim}
        \caption{ACIR para el programa de ejemplo con RangeCheck}
        \label{fig:ACIR_ejemplo_range}
    \end{figure}

    \item \texttt{XOR(num\_bits, w\textsubscript{left}, w\textsubscript{right}, w\textsubscript{out})}: restringe $w_{out}$ a ser el resultado de la operación de $XOR$ bit a bit entre los witnesses $w_{left}$ y $w_{right}$, asumiendo que estos tienen $num\_bits$ bits.
    
    \item \texttt{AND(num\_bits, w\textsubscript{left}, w\textsubscript{right}, w\textsubscript{out})}: restringe $w_{out}$ a ser el resultado de la operación de $AND$ bit a bit entre los witnesses $w_{left}$ y $w_{right}$, asumiendo que estos tienen $num\_bits$ bits.

    \item Funciones de hash como Sha256, Poseidon2, Keccak256, PedersenHash, Blake2s, Blake3, etc.

    \item Operaciones con puntos de curvas elípticas.
    
\end{itemize}

\subsection{BrilligCall}
Para explicar el opcode \texttt{BrilligCall} primero tenemos que hablar de las \textbf{unconstrained functions} en Noir. Noir permite definir funciones que no establecen restricciones sobre el código ACIR (de ahí el nombre \textit{unconstrained}). Estas se definen y se usan como se puede ver en la figura \ref{fig:noir_ejemplo_unconstrained}. El ACIR generado es bastante particular, y lo podemos ver en la figura \ref{fig:ACIR_ejemplo_unconstrained}. 

\begin{figure} 
    \centering
    \begin{verbatim}
    fn main(a: Field, b: Field) -> pub Field{
        suma_insegura(a, b)
    }
    
    unconstrained fn suma_insegura(a: Field, b: Field) -> Field {
        a+b
    }
    \end{verbatim}
    \caption{Programa de Noir con función \textit{unconstrained}}
    \label{fig:noir_ejemplo_unconstrained}
\end{figure}
\begin{figure} 
    \centering
    \begin{verbatim}
    private parameters indices : [0, 1]
    public parameters indices : []
    return value indices : [2]
    BRILLIG CALL inputs: [_0,_1] outputs: [_3]
    EXPR [ (1, _2) (-1, _3) 0 ]
    \end{verbatim}
    \caption{ACIR para el programa de ejemplo con función \textit{unconstrained}}
    \label{fig:ACIR_ejemplo_unconstrained}
\end{figure}

El ACIR en la última linea genera una restricción de la forma $w_2 = w_3$, donde $w_2$ es el output del programa y $w_3$ es el output del \texttt{BrilligCall} de la linea anterior. Pero ¿qué significa esta Brillig Call para el prover que va a leer el código ACIR? Recordemos que en el flujo de Noir descrito en la sección \ref{sec:noir} el compilador de Noir hace 2 cosas: por un lado genera el código ACIR y por otro, calcula a partir de los inputs provistos por el usuario un diccionario con valores para todos los witnesses. Un valor obtenido como resultado de un llamado a una función no restringida es una \textbf{pista} para el prover, es decir, un valor que no tiene restricciones. No es más que un witness que en el diccionario va a aparecer con un valor dado. El prover no tiene que hacer nada respecto al brillig, no tiene que establecer ninguna restricción nueva, solo tiene que poder acceder a su valor al momento de generar la prueba. Vamos a re-visitar este tema cuando veamos el flujo concreto con Plonky2. 

Por lo pronto, vamos a comentar que también existen usos implícitos de brillig call en la generación de código ACIR, por ejemplo cuando en un programa de Noir calculamos el inverso multiplicativo $\frac{1}{n}$ de un valor en $\Fp$. Esta cuenta requiere muchas más operaciones para hacerse que para verificarse, por lo tanto la estrategia de optimización que utiliza Noir es resolver el valor por un lado (al momento de resolver los witnesses) y verificarlo por otro (a través de AssertZeros). Este es un caso donde la verificación no sigue el mismo camino que todas las operaciones que se hicieron para llegar al resultado. Así como esta operación está incorporada en Noir, las \texttt{unconstrained functions} permiten que el usuario pueda elegir qué operaciones serán verificadas y cuáles no. 

\subsection{Ciclos en Noir}\label{sec:noir_loops}
Noir permite al programador usar ciclos como cualquier lenguaje de alto nivel, con la salvedad de que la cantidad de iteraciones tiene que estar definida en tiempo de generación de circuito. Esto es algo que también ocurre con la definición de listas en el lenguaje, las cuales tienen que tener un tamaño conocido en tiempo de generación de circuito. Pensemos durante un segundo por qué esta restricción existe. 

Un programa escrito en Noir va a traducirse en última instancia a un sistema de ecuaciones, donde estas están fijadas y no dependen de los valores que tomen las variables sobre las que predican. En cierto sentido, podemos pensar que la cantidad de operaciones está fija. Hacer un ciclo de tamaño variable (es decir, determinado por un input) es equivalente a definir un sistema de ecuaciones donde la cantidad de ecuaciones que lo conforman depende de los valores que tomen las variables. En otras palabras, no tiene sentido conceptualmente hablando.

Es posible diseñar programas que tengan ciclos con cantidad de iteraciones variable, pero estableciendo un máximo de iteraciones. También hay que tener en cuenta en esos casos que todas las ejecuciones que resulten de ese programa tendrán la misma cantidad de operaciones (equivalente a la cantidad máxima de iteraciones declarada). Esto es similar a lo que ocurre cuando usamos un término condicional: ambas partes de la guarda serán “evaluadas'' en términos del sistema de ecuaciones generado. 

Para pensarlo en términos de compiladores más tradicionales, los ciclos en Noir siempre son desdoblados en tiempo de generación de circuito. Todas las restricciones pertenecientes al cuerpo del ciclo se repetirán tantas veces como cantidad de iteraciones haya. Para que el compilador pueda hacer esto tiene que conocer esta cantidad de iteraciones.


\section{Barretenberg}
La mayoría del background técnico de este trabajo tiene como objetivo poder decir lo siguiente y que tenga sentido: \textbf{Barretenberg es un proving system basado en Turbo-PLONK\footnote{Actualmente Barretenberg ya no usa Turbo-PLONK sino que migró a otro proving system basado en el protocolo UltraHonk \cite{UltraHonk}. Hasta el momento que finalizó el desarrollo, Turbo-PLONK era la implementación por defecto.} que usa KZG como su Polynomial Commitment Scheme}. Esta misma frase no hubiera significado nada sin haber pasado por todo lo anterior, y si bien hay muchos detalles implementativos y de protocolo involucrados en el desarrollo de la herramienta, ahora por lo menos tenemos los recursos para entender conceptualmente qué está ocurriendo por debajo. 

Un proving system de estas características necesita un CRS para KZG, cuyo tamaño va a depender del largo de los programas que se deseen demostrar (ya que estos afectan directamente el tamaño de la traza). No hay casi documentación sobre Barretenberg, por lo tanto la mayoría de la investigación relacionada a su funcionamiento está en el código fuente. Primeramente, Barretenberg tiene que tener la capacidad de leer e interpretar código ACIR y los witnesses generados por Noir. No casualmente, fue creado con este propósito, y esta funcionalidad está incorporada en la herramienta.

Como ya mencioné en la introducción, la idea de este trabajo es atacar el problema del CRS en Barretenberg, habilitando a Noir para ser usado con un proving system que no lo requiera. El proving system elegido para esto es Plonky2. 